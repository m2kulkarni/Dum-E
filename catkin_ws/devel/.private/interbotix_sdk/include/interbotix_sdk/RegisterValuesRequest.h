// Generated by gencpp from file interbotix_sdk/RegisterValuesRequest.msg
// DO NOT EDIT!


#ifndef INTERBOTIX_SDK_MESSAGE_REGISTERVALUESREQUEST_H
#define INTERBOTIX_SDK_MESSAGE_REGISTERVALUESREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace interbotix_sdk
{
template <class ContainerAllocator>
struct RegisterValuesRequest_
{
  typedef RegisterValuesRequest_<ContainerAllocator> Type;

  RegisterValuesRequest_()
    : cmd(0)
    , motor_name()
    , addr_name()
    , value(0)  {
    }
  RegisterValuesRequest_(const ContainerAllocator& _alloc)
    : cmd(0)
    , motor_name(_alloc)
    , addr_name(_alloc)
    , value(0)  {
  (void)_alloc;
    }



   typedef int8_t _cmd_type;
  _cmd_type cmd;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _motor_name_type;
  _motor_name_type motor_name;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _addr_name_type;
  _addr_name_type addr_name;

   typedef int32_t _value_type;
  _value_type value;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ARM_JOINTS_AND_GRIPPER)
  #undef ARM_JOINTS_AND_GRIPPER
#endif
#if defined(_WIN32) && defined(ARM_JOINTS)
  #undef ARM_JOINTS
#endif
#if defined(_WIN32) && defined(GRIPPER)
  #undef GRIPPER
#endif
#if defined(_WIN32) && defined(SINGLE_MOTOR)
  #undef SINGLE_MOTOR
#endif

  enum {
    ARM_JOINTS_AND_GRIPPER = 1,
    ARM_JOINTS = 2,
    GRIPPER = 3,
    SINGLE_MOTOR = 4,
  };


  typedef boost::shared_ptr< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> const> ConstPtr;

}; // struct RegisterValuesRequest_

typedef ::interbotix_sdk::RegisterValuesRequest_<std::allocator<void> > RegisterValuesRequest;

typedef boost::shared_ptr< ::interbotix_sdk::RegisterValuesRequest > RegisterValuesRequestPtr;
typedef boost::shared_ptr< ::interbotix_sdk::RegisterValuesRequest const> RegisterValuesRequestConstPtr;

// constants requiring out of line definition

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator1> & lhs, const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator2> & rhs)
{
  return lhs.cmd == rhs.cmd &&
    lhs.motor_name == rhs.motor_name &&
    lhs.addr_name == rhs.addr_name &&
    lhs.value == rhs.value;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator1> & lhs, const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace interbotix_sdk

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "725e8187efb86073bd6c7e5fa5bb725f";
  }

  static const char* value(const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x725e8187efb86073ULL;
  static const uint64_t static_value2 = 0xbd6c7e5fa5bb725fULL;
};

template<class ContainerAllocator>
struct DataType< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "interbotix_sdk/RegisterValuesRequest";
  }

  static const char* value(const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"int8 ARM_JOINTS_AND_GRIPPER = 1\n"
"int8 ARM_JOINTS = 2\n"
"int8 GRIPPER = 3\n"
"int8 SINGLE_MOTOR = 4\n"
"\n"
"int8 cmd\n"
"string motor_name\n"
"string addr_name\n"
"int32 value\n"
;
  }

  static const char* value(const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.cmd);
      stream.next(m.motor_name);
      stream.next(m.addr_name);
      stream.next(m.value);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RegisterValuesRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::interbotix_sdk::RegisterValuesRequest_<ContainerAllocator>& v)
  {
    s << indent << "cmd: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cmd);
    s << indent << "motor_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.motor_name);
    s << indent << "addr_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.addr_name);
    s << indent << "value: ";
    Printer<int32_t>::stream(s, indent + "  ", v.value);
  }
};

} // namespace message_operations
} // namespace ros

#endif // INTERBOTIX_SDK_MESSAGE_REGISTERVALUESREQUEST_H
